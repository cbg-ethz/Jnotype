# Snakefile
#===============================================================================
# Generate N=300 genotypes for G in {5, 10, 30} from an Ising model.
# Off-diagonal entries are sampled from a spike-and-slab prior (80% zero entries,
# otherwise drawn from Normal(0, 5^2)), and diagonal entries are drawn from
# Normal(0, 5^2).
#===============================================================================

import os
import sys
from pathlib import Path

import jax
import jax.numpy as jnp
import jax.random as jrandom

# TODO: there's a difference between .venv and conda environment. 
# Figure out how to make conda environment work with whole project imports
from workflow import *
from _sampling import *

# -------------------------
# PARAMETERS
# -------------------------
N_SAMPLES = 300
G_LIST = [5, 10, 30]
RANDOM_SEED = 42
SPIKE_WEIGHT = 0.8
SCALE = 5.0

# -------------------------
# PATHS
# -------------------------
OUTPUT_DIR = Path("data")
os.makedirs(OUTPUT_DIR, exist_ok=True)

# -------------------------
# Snakemake Rules
# -------------------------

rule all:
    input:
        expand(f"{OUTPUT_DIR}/G_{{g}}/genotypes.npy", g=G_LIST),
        expand(f"{OUTPUT_DIR}/G_{{g}}/weights.npy", g=G_LIST)

rule initialize_ising_model:
    """Initialize the Ising model weights."""
    output:
        weights = f"{OUTPUT_DIR}/G_{{g}}/weights.npy"
    params:
        spike_weight=SPIKE_WEIGHT,
        scale=SCALE
    run:
        key = jrandom.PRNGKey(RANDOM_SEED)
        g = int(wildcards.g)
        os.makedirs(f"{OUTPUT_DIR}/G_{g}", exist_ok=True)
        
        mat = sample_ising_model_matrix(
            key, 
            g, 
            p_zero=params.spike_weight, 
            scale=params.scale
        )
        jnp.save(output.weights, mat)

rule sample_genotypes:
    """Generate samples from the Ising model."""
    input:
        weights = f"{OUTPUT_DIR}/G_{{g}}/weights.npy"
    output:
        genotypes = f"{OUTPUT_DIR}/G_{{g}}/genotypes.npy"
    params:
        n_samples=N_SAMPLES
    run:
        g = int(wildcards.g)
        key = jrandom.PRNGKey(RANDOM_SEED)
        mat = jnp.load(input.weights)
        unnorm_log_prob_fn = unnorm_log_prob_ising_model(mat)
        
        if g <= 10: 
            samples = categorical_exact_sampling(key, params.n_samples, g, unnorm_log_prob_fn)
        else:
            kernel_key, init_key = jrandom.split(key, 2)
            kernel = construct_systematic_bitflip_kernel(unnorm_log_prob_fn)
            
            initial_samples = jrandom.bernoulli(
                init_key, 
                p=0.5, 
                shape=(params.n_samples, g)
            )
            
            def run_chain(init_sample, subkey):
                return gibbs_sample(
                    key=subkey,
                    kernel=kernel,
                    initial_sample=init_sample,
                    num_steps=1,
                    warmup=1000
                )[0]
            
            chain_keys = jrandom.split(kernel_key, params.n_samples)
            samples = jax.vmap(run_chain)(initial_samples, chain_keys)
            
        jnp.save(output.genotypes, samples)

